# 字符标识 和 字符的具体字节表述
谈谈我的理解：

一个字符串存在的形式大致可以分为两类：一类用于人类可读的文本字符串，另一个用于储存在计算机储存中的 字节序列.

人类可读的文本字符串 就是 Unicode字符， 也叫码位。他是人类可以直接理解的字符串。

字符的字节序列，人读取时可能会认为是乱码，因此字节序列不是给人读取的，而是以一种储存格式储存在计算机中的 。储存的格式不同，那么字符的字节序列就不同。

我们在编辑器中编辑的文本，都是可以理解的，所以这些文本都是 Unicode字符. 
由于硬盘中储存的是字节序列，所以当我们需要保存这些文本到本地硬盘中时，就必须先将Unicode字符编码为某种格式的字节序列，再才能写入硬盘（这个操作，一般软件会帮我们完成，我们只需在"写入函数write"中指定编码方式,encoding = '编码方式'）。

编码方式有很多种，比如UTF-8 , bdg12030。

由于人们希望看到的是可读字符串，所以当我们需要从硬盘中读取文本时，就必须先将硬盘中的字节序列 以它编码时的格式 解码 为 Unicode字符. （这个操作，一般软件会帮我们完成，我们只需在"读取函数read/open"中指定编码方式,decoding = '编码方式'）。解码的格式 应该是这个字节序列 编码时 格式。如果不对应，就会出现乱码。

 
 编码：  encode, 把 码位 转换为 字节序列, 即把字符串 编码为 用于储存或者传输的 字节序列
 解码： deocde， 把 字节序列 转换为 码位 ，即把字节序列 解码为 人类可读的文本字符串
 
 
 字节序列 有各种各样的存储方式。
 Unicode字符 只有一种，用于人类可读。
 
 字节序列： 晦涩难懂的机器磁芯转储
 Unicode字符串：“人类可读”的文本
 
 注意：
 从python3开始,  str对象中获取的元素是Unicode字符.
python2的str对象中获取的是字节序列.不过python2有unicode类型。
所以，python3的str类型基本上相当于python2的unicode类型.

```python
>>> s = 'abc'
>>> s.encode('utf-8')
b'abc'  //引号左边最开始是b , 表明结果是一个二进制序列， 即字节序列
>>> a = s.encode('utf-8')
>>> a.decode('utf-8')
'abc'
```
# python中的字节序列
**字节序列了类型 就是常说的 二进制序列类型**

python内置了两种基本的二进制序列类型：
	1.  从python2.6开始，添加的可变bytearray类型
	2.  python3 引入的不可变bytes类型

1. python2的str对象就是二进制类型，但在python3中，引入了不可变bytes类型, 而将str对象转化为Unicode字符类型.
2. 虽然python2的str类型就是二进制类型， 但是新的二进制序列类型（比如python3的bytes类型, python2.6的bytearray类型）在很多方面与python2的str类型又有很大的不同。
3. python2.6也有bytes类型，但这只是python2的str类型的别名，与pytho3的bytes类型是不同的.

**bytes或bytearray对象的各个元素是介于0~255之间的整数**
```python
>>> c = bytes('cofe', encoding = 'utf-8')
>>> c
b'cofe'  //有个b，表明是二进制序列

>>> c = bytes('大家好', encoding = 'utf-8')
>>> c
b'\xe5\xa4\xa7\xe5\xae\xb6\xe5\xa5\xbd'
```
# str类型，字节序列 与 其他类型序列 在处理 s[0] ,s[:1]的差异
对于str类型:
s[0] 是一个str类型， s[:1]也是一个str类型， 所以有 s[0] == s[:1]
```python
>>> s = "cofe"
>>> s[0]
'c'
>>> s[:1]
'c'
>>> type(s[0])
<class 'str'>
>>> type(s[:1])
<class 'str'>
>>> s[0] == s[:1]
True
```

对于 字节序列 和 其他类型序列 而言：
s[0] 得到的是 元素
s[:1] 得到的是 一个与 s 相同类型的序列
比如当s 是一个列表list时, s = [1,2,3]，那么s[0]得到的是元素 1,  s[:1]得到与s相同类型的序列（这里是list）即[1].

```python
>>> s = [1,2,3]
>>> s[0]
1
>>> s[:1]
[1]
>>> type(s[0])
<class 'int'>
>>> type(s[:1])
<class 'list'>
>>> s[0] == s[:1]
False

```

于此类似，字节序列也是一样。
s[0] 得到的是 元素
s[:1] 得到的是 一个与 s 相同类型的序列（bytes是一个序列）

```python
>>> s = bytes("cofe", encoding = 'utf-8')
>>> s[0]
99
>>> s[:1]
b'c'
>>> s[:2]
b'co'
>>> type(s[0])
<class 'int'>
>>> type(s[:1])
<class 'bytes'>
>>> type(s[:2])
<class 'bytes'>
>>> s[0] == s[:1]
False

```

**总之： 二进制序列的切片始终是同一种编码的二进制序列**
**任何类型的序列的切片始终是同一类型的序列**

# 二进制序列各个字节的值 可能出现的三种形式
**看一个字符序列是不是二进制序列，打印的时候看最开始有没有b,比如b'aa'，就是一个二进制序列，而'aa'可能就是一个Unicode字符了**
1. 对可打印的ASCII范围内的字节，直接使用ASCII字符本身。
比如，前面的字节形式的'c', 'o' .直接显示为 b'c', b'o' . 这里b表明这是二进制字符.
2. 制表符， 换行符， 回车符 和 \ 对应的字节，使用转义序列\t, \n, \r 和 \ \    .
3. 其他字节的值， 使用十六进制转义序列（例如，\x00是空字节）

# memoryview 模块 和 struct 模块
1. struct 模块：**可以从二进制序列中提取结构化的信息**
可以将打包的字节序列按照自己要求转换成不同类型字段组成的元组。同时还可以进行反向转换，把元组转换成打包的字节序列。
struct 模块可以处理bytes, bytearray 和 memoryview对象.

2. memoryview 内存视图对象 允许在二进制数据结构之间共享内存。
你可以字节访问数据的切片，而无需复制字节序列。

# 几种基本的编码格式
上面已经讲过，将Unicode 字符转为 字节序列(即二进制序列) 的过程 叫做 编码。

同一个Unicode 字符(人类可读的) 用不同的编码方式可以产生 不同的二进制序列(可理解为保存到硬盘中的).

python 自带了超过100种编解码格式.

为什么需要这么多编解码格式呢？
因为 想要将Unicode 字符保存到硬盘中，就必须将Unicode 字符转为二进制序列。那么我们就要找到 一种方式 让 每一个不同的Unicode 字符 与一个二进制序列一一对应。
人类有各种语言，那么Unicode 字符(人类可读的) 就非常非常的多，我们很难设计出一种二进制序列 与 地球的所有Unicode 字符 一一对应。即使有，那这种对应关系表也会非常大，计算机查找缓慢，不好存储。
而且比如说，对于说英语的人，就不可能用到 巴西语。 那么说英语的人只使用 只对应英文字母的二进制序列的编码方式就可以了。

所以，我们只是把那个最大的二进制序列的对应表，拆分成 各个不同的小表，我们只需使用 我们需要的那个小表就可以了。比如 gb2312仅仅处理
## 下面讲解一下


