# 集合论
# 集合包括　set 和　frozenset
set 和　frozenset都是集合．
只是set类型的集合内部的值是无序排序　且　可变的，有add（），remove（）等方法。所以set类型不可散列的．
但是frozenset类型的集合内部的值是不可变的．一旦创建便不能更改，没有add，remove方法。所以forzenset可散列的．


+ 集合中的元素必须是可散列的，set类型本身是不可散列的，但是forzenset可以散列. 也就是想让集合里面的元素也是集合的话，就是创建一个包含不同forzenset的set.
+ 集合的本质是许多唯一对象的聚集．也就是保证**唯一性**. 所以集合可以用来**去重**.
+ 集合实现了很多基础的**中缀运算符**.
	+ 合集　a | b
	+ 交集　a & b
	+ 差集　a - b

**灵活的运用　集合的 　 唯一性　和 　中缀运算符 　 可以大大简化python的可读性，和　程序运行时间(前提是中缀运算符中有一个对象本身就是集合)（因为将对象转为集合set(a)也有时间成本）．**

# 创建集合
```python
>>> a = [1,1]
>>> set(a)
{1}
```
#　构建集合
## set
##  特殊字面量句法
```python
>>>{1,2}
>>>{'a', 'q'}
>>>set()
```
##  类型转换
```python
>>>set([1,2,3])
```
## 集合推导
见后面讲解

## frozenset
frozenset没有特殊字面量句法，只有采用构造方法．或者强制转换
```python
>>> frozenset(range(10))
```

#  空集合，set() 和 \{\}
一般的，集合的表示为{1, 2} ,  {'a', 'b'}．但是对于空集合却不是{}．
{} 表示的是　空字典.
set() 才表示　空集合.

```python
>>> {1, 1}
{1}
>>> type({1,1})
<class 'set'>

>>> a = set()
>>> a
set()
>>> type(a)
<class 'set'>

>>> type(set())
<class 'set'>

>>> type({})
<class 'dict'>
```

# 集合推导
```python
>>> {i for i in range(10)}
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```


# 集合set的实现以及导致的结果
set 和　frozenset 的实现　也是　依赖于散列表.
与dict不同的是，dict的散列表是　通过键key的hash值找到表元, 每个表元　存放的是　键key:值value. 
而　set 和　frozenset 的散列表　是通过集合里的元素的hash值找到表元，每个表元存放的也是　键key:值value，只是value是一个没有意义的值.

## 集合的特性（优点和缺点）
与 字典和散列表几乎一样. (不明白可以跳到字典的这一部分对比的看)
1. 集合的元素必须可散列的.
2. 集合非常消耗内存.
3. 可以很高效的判断元素是否存在于某个集合中．
4. 元素的次序取决于被添加到集合里的次序．
（**即若两个集合的元素相同，但是次序不同，这两个集合依然是相同的**）
5. 在集合中添加元素，可能会改变集合里已有元素的次序.